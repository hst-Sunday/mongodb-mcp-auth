worker_processes  auto;
pid /tmp/nginx.pid;

events {
  worker_connections  1024;
}


http {
  # 基础优化
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;
  sendfile      on;
  tcp_nopush    on;
  tcp_nodelay   on;
  keepalive_timeout 75s;

  # 详细访问日志，便于排查上游状态与耗时
  log_format mcp_main '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent '
                      '"$http_user_agent" $request_time $upstream_status $upstream_response_time '
                      'conn:$connection reqs:$connection_requests host:$host method:$request_method accept:"$http_accept"';
  access_log /dev/stdout mcp_main;

  # 配置临时目录到用户可写的位置
  client_body_temp_path /tmp/nginx/client_temp;
  proxy_temp_path       /tmp/nginx/proxy_temp;
  fastcgi_temp_path     /tmp/nginx/fastcgi_temp;
  uwsgi_temp_path       /tmp/nginx/uwsgi_temp;
  scgi_temp_path        /tmp/nginx/scgi_temp;


  # 使用 Bearer Token 鉴权

  # 仅在 WebSocket 升级时设置 Connection: upgrade；否则保持 keep-alive（SSE 友好）
  map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      keep-alive;
  }

  # 允许的 Host 白名单（由启动脚本通过环境变量 ALLOWED_HOSTS 生成）
  # 示例：ALLOWED_HOSTS="api.example2.com,api.example.com"
  # 生成正则：^(api\.example2\.com|api\.example\.com)$；未设置时为 .*
  map $host $is_allowed_host {
    default 0;
    ~^(${ALLOWED_HOSTS_REGEX})$ 1;
  }

  # 日志（按需）
  # access_log  /var/log/nginx/access.log  main;
  # error_log   /var/log/nginx/error.log   warn;

  # 上游到同容器内的 MCP Server（统一镜像场景）
  upstream mcp_upstream {
    server 127.0.0.1:3000;
    keepalive 64;
  }

  server {
    listen 8080;
    server_name localhost; # 替换为你的域名

    # Bearer Token 从环境变量 BEARER_TOKEN 读取，启动时通过 envsubst 替换
    # 运行时使用 -e BEARER_TOKEN="your_token" 设置
    set $expected_bearer "${BEARER_TOKEN}";

    # 通用反代设置（SSE 友好）
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # 可选：转发 Authorization 头到后端（Basic）

    # SSE 需要关闭缓冲
    proxy_buffering off;
    proxy_cache off;
    proxy_request_buffering off;

    # 长连接与心跳相关（按需调整）
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    # CORS 预检改为在具体 location 中处理，避免在 server 级别使用 add_header

    # 如果后端或中间件需要保持连接升级（一般 SSE 不需要 upgrade，但确保不被错误处理）
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    # Host 白名单校验（不在白名单直接关闭连接）
    if ($is_allowed_host = 0) { return 444; }

    # 专用：MCP 主端点（SSE/长连接友好）
    location = /mcp {
        # 一些客户端会用 GET 探活，直接返回 200，避免转发给上游导致 400
        if ($request_method = GET) { return 200; }
        if ($request_method = OPTIONS) { return 204; }
        if ($http_authorization = "") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        if ($http_authorization != "Bearer $expected_bearer") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        proxy_pass http://mcp_upstream;
        proxy_buffering off;
        proxy_request_buffering off;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
        # SSE 不需要 upgrade，保持 keep-alive
        proxy_set_header Upgrade "";
        proxy_set_header Connection "keep-alive";
        # 不向后端转发外部 Authorization，避免干扰
        proxy_set_header Authorization "";
    }

    # 兜底：其他路径（如根路径探活等）
    location / {
        if ($request_method = OPTIONS) { return 204; }
        if ($http_authorization = "") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        if ($http_authorization != "Bearer $expected_bearer") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        proxy_pass http://mcp_upstream;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_set_header Authorization "";
    }

  }
}

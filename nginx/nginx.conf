user  nginx;
worker_processes  auto;

events {
  worker_connections  1024;
}


http {
  # 基础优化
  include       mime.types;
  default_type  application/octet-stream;
  sendfile      on;
  tcp_nopush    on;
  tcp_nodelay   on;
  keepalive_timeout 65;


  # 使用 Bearer Token 鉴权

  map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
  }

  # 日志（按需）
  # access_log  /var/log/nginx/access.log  main;
  # error_log   /var/log/nginx/error.log   warn;

  # 上游到同容器内的 MCP Server（统一镜像场景）
  upstream mcp_upstream {
    server 127.0.0.1:3000;
    keepalive 64;
  }

  server {
    listen 80;
    server_name localhost; # 替换为你的域名

    # Bearer Token 从环境变量 BEARER_TOKEN 读取，启动时通过 envsubst 替换
    # 运行时使用 -e BEARER_TOKEN="your_token" 设置
    set $expected_bearer "${BEARER_TOKEN}";

    # 通用反代设置（SSE 友好）
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # 可选：转发 Authorization 头到后端（Basic）

    # SSE 需要关闭缓冲
    proxy_buffering off;
    proxy_cache off;

    # 长连接与心跳相关（按需调整）
    proxy_read_timeout 600s;
    proxy_send_timeout 600s;

    # CORS 预检改为在具体 location 中处理，避免在 server 级别使用 add_header

    # 如果后端或中间件需要保持连接升级（一般 SSE 不需要 upgrade，但确保不被错误处理）
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    # 鉴权由各 location 使用 auth_basic 控制

    # 允许公开访问的发现端点（不鉴权），让客户端能读取 OAuth/.well-known 信息
    location ^~ /.well-known/ {
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept, Cache-Control, X-Requested-With" always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
        proxy_pass http://mcp_upstream;
    }

    # 兜底：其余路径也进行 Bearer Token 鉴权
    location / {
        if ($request_method = OPTIONS) { return 204; }
        if ($http_authorization = "") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        if ($http_authorization != "Bearer $expected_bearer") {
            add_header WWW-Authenticate 'Bearer realm="mcp"';
            return 401;
        }
        proxy_pass http://mcp_upstream;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }

  }
}
